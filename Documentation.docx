a. Introduction
    User Datagram Protocol (UDP) is a connectionless, best-effort transport protocol with minimal overhead. This results in highly speedy communication, as the protocol does not require a handshake or acknowledgement before transferring data to the destination. However, this speed comes with trade-offs. Packets can be lost in transit, making UDP unreliable for guaranteed data transfer. Furthermore, UDP suffers from unordered delivery, statelessness, and a lack of congestion control.

    Because Transmission Control Protocol (TCP) is designed to be reliable and complete, it is often preferred for critical data transfer. To bridge this gap, this project introduces an implementation of TCP features over a UDP foundation using Python socket programming. This implementation integrates core TCP mechanics—such as acknowledgements, session management, error handling, and retransmission strategies—to support a reliable file transfer protocol.
b. Protocol Overview
    i. Swimlane diagrams and description of protocol message exchanges
c. Packet Message Formats
    Every packet uses a fixed-size header followed by the payload.

    i.    Message Types: 1-byte

            0x00 (SYN): Connection request.

            0x01 (DATA): Payload containing file data.

            0x02 (ACK): Acknowledgment of a packet.

            0x03 (FIN): Connection termination.

            0x04 (ERR): Error (e.g., File Not Found).


    ii.   Sequence Number: A 4-byte integer to track order and detect duplicates.

    iii.  Payload Length: A 2-byte integer indicating the size of the data segment

    iv.  Payload : The hash of the segmented data 

d. State Machines (Transition Diagram)
    i. Client
    ii. Server
e. Explanation of reliability mechanisms
    i. Retransmission: If an ACK is not received within a 500ms timeout window, the sender re-transmits the last DATA packet.

    ii.Ordered Delivery: The receiver discards any packet with a sequence number it has already processed to prevent data corruption.
f. Error-handling
    Timeout & Retransmission: Since UDP does not guarantee delivery, if a sender (Client or Server) does not receive an ACK for a sent packet within a predefined window, it must assume the packet was lost and retransmit it.

    File Not Found: If a client requests a file via /get that does not exist on the server, the server must respond with a specific ERROR (Type 4) packet. In your previous code, this was a simple string; now it must be a structured protocol message.

    Session Mismatch: The protocol must detect "Unexpected Packets." If the server receives a data packet with a sequence number it has already processed, or a packet from a session it doesn't recognize, it must ignore the packet or send an error response to maintain synchronization.

    Binary Safety: Error handling includes ensuring that non-text files (images, executables) are transmitted without corruption by treating the payload as raw bytes, preventing encoding errors from crashing the session.
g. File Transfer Operations
h. End-of-file Signaling
    The FIN Exchange: Following the completion of the data transfer, the sender initiates a clean termination by sending a FIN (Type 3) packet.

    Explicit Termination: The receiver must acknowledge this with a FIN-ACK or a session close message to confirm that all packets have been reassembled and the file is safely stored.

    Ordered Reassembly: The receiver uses the sequence numbers to ensure all parts of the file are present; the EOF signal (FIN) acts as the trigger to finally write the reassembled buffer to the local disk.
